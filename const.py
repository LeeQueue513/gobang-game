# 本文件存放所有用到的常量


# 总体使用
# 棋盘的行列数
SIDE_LEN = 15
# 棋盘棋子
HUMAN, AI, EMPTY = -1, 1, 0


# 评估函数使用
# 棋型
CHESS_TYPE_NUM = 7  # 棋型总数
FIVE = 0     # 连五
LFOUR = 1    # 活四
CFOUR = 2    # 冲四
LTHREE = 3    # 活三
STHREE = 4    # 眠三
LTWO = 5     # 活二
STWO = 6     # 眠二
# 棋型
SHAPE_LIST = [
    # 各棋型存储为三元组，分别为
    # ([棋型列表],列表元素个数,列表倒中最后一个1的后面一位的下标)
    # 每种不对称棋型都有两种情况
    # 连五
    [
        ([1, 1, 1, 1, 1], 5, 5),
    ],
    # 活四
    [
        ([0, 1, 1, 1, 1, 0], 6, 5),
    ],
    # 冲四
    [
        ([1, 1, 1, 1, 0], 5, 4),
        ([0, 1, 1, 1, 1], 5, 5),
        ([1, 1, 1, 0, 1], 5, 5),
        ([1, 0, 1, 1, 1], 5, 5),
        ([1, 1, 0, 1, 1], 5, 5),
    ],
    # 活三
    [
        ([0, 1, 1, 1, 0, 0], 6, 4),
        ([0, 0, 1, 1, 1, 0], 6, 5),
        ([0, 1, 1, 0, 1, 0], 6, 5),
        ([0, 1, 0, 1, 1, 0], 6, 5),
    ],
    # 眠三
    [
        ([1, 1, 1, 0, 0], 5, 3),
        ([0, 0, 1, 1, 1], 5, 5),
        ([0, 1, 1, 1, 0], 5, 4),
        ([1, 1, 0, 1, 0], 5, 4),
        # ([1, 1, 0, 0, 1], 5, 5),
        ([1, 0, 1, 1, 0], 5, 4),
        # ([1, 0, 0, 1, 1], 5, 5),
        ([0, 1, 1, 0, 1], 5, 5),
        ([0, 1, 0, 1, 1], 5, 5),
        ([1, 0, 1, 0, 1], 5, 5),
    ],
    # 活二
    [
        ([0, 1, 1, 0, 0, 0], 6, 3),
        ([0, 0, 1, 1, 0, 0], 6, 4),
        ([0, 0, 0, 1, 1, 0], 6, 5),
        ([0, 1, 0, 1, 0, 0], 6, 4),
        ([0, 0, 1, 0, 1, 0], 6, 5),
        # ([0, 1, 0, 0, 1, 0], 6, 5),
    ],
    # 眠二
    [
        ([1, 1, 0, 0, 0], 5, 2),
        ([0, 1, 1, 0, 0], 5, 3),
        ([0, 0, 1, 1, 0], 5, 4),
        ([0, 0, 0, 1, 1], 5, 5),
        ([1, 0, 1, 0, 0], 5, 3),
        ([0, 1, 0, 1, 0], 5, 4),
        ([0, 0, 1, 0, 1], 5, 5),
        # ([1, 0, 0, 1, 0], 5, 4),
        # ([0, 1, 0, 0, 1], 5, 5),
    ],
]
# 棋型对应分值,注意顺序必须匹配
SHAPE_SCORE = [
    99999,  # 连五
    8000,   # 活四
    4000,   # 冲四  双冲四/双活三相当于活四
    4000,   # 活三
    300,    # 眠三
    300,    # 活二
    50,     # 眠二
]
BONUS_SCORE = 1000  # 行棋者的加分


# 生成函数使用
LIMIT_GENERATE_NUM = 6     # 生成函数生成的可能位置个数的限制
# 空位分值，使得分数相同时ai趋向于向棋盘中间部分下子
POS_SCORE = [[(SIDE_LEN//2-max(abs(r-SIDE_LEN//2), abs(c-SIDE_LEN//2)))
              for r in range(SIDE_LEN)] for c in range(SIDE_LEN)]


# 极大极小搜索
DEPTH = 2   # 搜索深度
MAX_P = AI  # 极大节点是ai
MIN_P = HUMAN
SCORE_MAX, SCORE_MIN = SHAPE_SCORE[FIVE]+1, -SHAPE_SCORE[FIVE]-1    # 防止必赢场面出错
